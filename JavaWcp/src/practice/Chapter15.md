# Chapter15 演習問題

## 1 再帰の問題
### 問題
最大公約数を「ユークリッドの互除法」で算出する再帰メソッドを呼び出して、以下の実行結果になるように「Chapter15_1.java」を作成してください。  

実行結果

```
976 と 427 の最大公約数は、61 です。
```

> <ユークリッドの互除法の計算方法>
>
> 大きい数を小さい数（割った数）で割り、割った数を余りで割ります。さらに割った数を余りで割り、余りが0になるまで計算します。余りが0になった時の割った数が最大公約数となります。

例）148 と 28 の最大公約数  
　148 % 28 = 16　← 大きい数（148）を小さい数（28）で割る  
　28 % 16 = 12　 ← 割った数（28）を余り（16）で割る  
　16 % 12 = 4 　 ← さらに割った数（16）を余り（12）で割る  
　12 % 4 = 0   　← さらに計算して、余りが0になった時の割った数（4）が最大公約数  

- 最大公約数  
幾つかの数の共通の約数のうち、最大のもの

```java
public class Chapter15_1 {
	public static void main(String[] args) {
        int a = 976;
        int b = 427;
        System.out.println(a + " と " + b + " の最大公約数は、" + gcd(a, b) + "です。");
    }

    // ユークリッドの互除法で最大公約数を計算するメソッド
    static int gcd(int a, int b) {
    		...
    }
}
```

### 処理内容
1. aとbがどちらが大きいかのチェック
1. 大きい数を小さい数で割ったあまりを算出する処理
1. 割った数を余りで割る処理
1. あまりが0になるまで3.のステップを繰り返す
1. あまりが0になったらその時割った数を数値として返す

#### Step3の方法
148 % 28 = 16　← 大きい数（148）を小さい数（28）で割る  
a % b = x

28 % 16 = 12　 ← 割った数（28）を余り（16）で割る  
b % x = y  

ということは？

a %= bでいいのでは？

#### Step1は必要ない
なぜならば  
小さい数から大きい数を割った時のあまりは割られる数になるためである。

```java
System.out.println(976 / 427); //2
System.out.println(976 % 427); //122

System.out.println(427 / 976); //0
System.out.println(427 % 976); //427
```

### 正解

```java
package practice;

public class Chapter15_1 {
    public static void main(String[] args) {
        int a = 976;
        int b = 427;
        System.out.println(a + " と " + b + " の最大公約数は、" + gcd(a, b) + "です。");
    }

    // ユークリッドの互除法で最大公約数を計算するメソッド
    static int gcd(int a, int b) {
        // b(余り)が0になった時のaが最大公約数
        if (b == 0) {
            return a;
        }
        // 再帰呼び出し
        return gcd(b, a % b);
    }
}
```


## 2 ファイルの入出力の問題
### 問題
JavaWcpの直下に「resources」ディレクトリ作成して、ディレクトリに以下の「input.txt」ファイルを作成してください。
作成した「input.txt」ファイルの読み込んで「output.txt」ファイルを出力するプログラム「Chapter15_2.java」を完成させてください。

### 解答
- IOExceprion  
入出力処理の失敗、または割り込みの発生によって生成される例外の汎用クラス


- Filesクラス

> Java1.7より追加されたAPIであるFilesクラスで、Fileクラスよりも高度なファイル操作を行うことができる。
Filesクラスは、基本的にPathクラスを引数にする。

```java
Path path = Paths.get("テスト");
Files.createDirectory(path);
```
このクラスファイルが存在するディレクトリに「テスト」という名前でディレクトリを新規作成する。

```java
Path path = Paths.get("テスト");
Files.createFile(path);
```
このクラスファイルが存在するディレクトリに「テスト」という名前でファイルを新規作成する。

- FileSystems.getDefaultメソッド
現在のファイルシステム取得

- Pathオブジェクトとは？  
Files クラスで用意されているメソッド使ってファイルやディレクトリに関する操作を行う場合に、ファイルやディレクトリを表すのに Path オブジェクトを作成して使用する。

- getPathメソッド  
Pathオブジェクトの生成ができる。

```java
Fileオブジェクト.getPath();
```

- BufferedReader

> テキストファイルを読み込むためのクラス。

- readlineメソッド

> テキストファイルを1行ずつ読み込むメソッド

BufferedReader bufferedReader = new BufferedReader(Fileオブジェクト);


### 正解

解説
「try-with-resources」文の基本構文は以下になります。

```java
try (初期化処理;) { 
    tryブロック（例外が発生する可能性がある処理）
} catch (例外クラス 変数名) {
    catchブロック（例外が発生した時に実行する処理）
} finally { 
    finallyブロック(例外発生の有無にかかわらず必ず実行する処理)
}
```

「try-catch-finally」文とほとんど同じですが、try文の後に「(初期化処理)」を記述する必要があります。
初期化処理では、クローズ処理を行う必要があるリソース関連クラスのインスタンスを生成します。「;」区切りで複数のリソースの初期ができます。
Javaでは、リソースをオープンした場合（インスタンスを生成した場合）は、必ず、クローズ処理をする必要があります。Java6以前は、finallyブロックにクローズ処理を記述する必要がありましたが、記述漏れなどによって、大きな問題が発生することがよくありました。
しかし、Java7以降に追加された「try-with-resources」はクローズ処理の記述が不要のため、記述漏れの心配がなく、また、ソースコードもすっきりするようになりました。


## 3 プリミティブ型のキャストの問題
### 問題
プリミティブ型のキャストについての問題です。キャストする場合は、参照型のダウンキャストと同じように「変数名 = (型) 元の変数名」で変換できます。

以下の実行結果になるように、コンパイルエラーのプログラム「Chapter15_3.java」にキャストを追加してください。

- 実行結果
 
```java
123.0
12
0.5
-128
```

### 解答
- プリミティブ型とは？  
Javaにおけるプリミティブ型とは、short型、byte型、long型、int型、double型、float型、char型、boolean型の8つの型を指します。  
プリミティブ型とは違うのが、参照型。  
参照型とはclass型、interface型、型変数、array型の4種類の総称です。

- キャストとは？
データ型を変換することを型キャストと言います。  
まず、基本型では、小さな型を大きな型に代入（たとえば、int型の値をlong型に代入）することは可能です。大は小を兼ねるのです。これを拡大変換と言います。  
しかし、その逆（縮小変換）はそのままでは不可です。long型の値がint型に格納できるとは限らないからです。  
そこで、明示的にlong型の値をint型にキャスト（変換）する必要があります。キャストには、対象の変数の直前に「(型名)」を付与するだけです。  

```java
long l = 50;
int i = (int)l;
System.out.println(1+i);
```


## 4 スレッドの問題
### 問題
スレッドとは、プログラムを処理する単位のことです。Javaのプログラムはスレッドによって実行されています。Javaでは複数のスレッド（マルチスレッド）を同時に実行することで並列処理を行うことができます。
Javaでスレッドを作成する方法は、Threadクラスを継承したクラスを作成する方法とRunnableインターフェースを実装したクラスを作成する方法の2つがあります。

マルチスレッドのプログラムを作成する機会はあまりないと思いますが、非常に大事なJavaの機能なので、調べながら挑戦してみてください。

#### 問題
以下の実行結果になるように、「Chapter15_4.java」と「ThreadSample.java」を作成してください。

- 実行結果 ※出力される順序は実行するごとに変わります

```java
ThreadSample2のスレッド : 1回目
Chapter15_4のスレッド : 1回目
ThreadSample1のスレッド : 1回目
ThreadSample2のスレッド : 2回目
ThreadSample1のスレッド : 2回目
Chapter15_4のスレッド : 2回目
ThreadSample2のスレッド : 3回目
Chapter15_4のスレッド : 3回目
ThreadSample1のスレッド : 3回目
```

### 正解
正解　よって修正箇所なし
