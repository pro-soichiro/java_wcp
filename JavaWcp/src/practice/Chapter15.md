# Chapter15 演習問題

## 1 再帰の問題
### 問題
最大公約数を「ユークリッドの互除法」で算出する再帰メソッドを呼び出して、以下の実行結果になるように「Chapter15_1.java」を作成してください。  

実行結果

```
976 と 427 の最大公約数は、61 です。
```

> <ユークリッドの互除法の計算方法>
>
> 大きい数を小さい数（割った数）で割り、割った数を余りで割ります。さらに割った数を余りで割り、余りが0になるまで計算します。余りが0になった時の割った数が最大公約数となります。

例）148 と 28 の最大公約数  
　148 % 28 = 16　← 大きい数（148）を小さい数（28）で割る  
　28 % 16 = 12　 ← 割った数（28）を余り（16）で割る  
　16 % 12 = 4 　 ← さらに割った数（16）を余り（12）で割る  
　12 % 4 = 0   　← さらに計算して、余りが0になった時の割った数（4）が最大公約数  

- 最大公約数  
幾つかの数の共通の約数のうち、最大のもの

```java
public class Chapter15_1 {
	public static void main(String[] args) {
        int a = 976;
        int b = 427;
        System.out.println(a + " と " + b + " の最大公約数は、" + gcd(a, b) + "です。");
    }

    // ユークリッドの互除法で最大公約数を計算するメソッド
    static int gcd(int a, int b) {
    		...
    }
}
```

### 処理内容
1. aとbがどちらが大きいかのチェック
1. 大きい数を小さい数で割ったあまりを算出する処理
1. 割った数を余りで割る処理
1. あまりが0になるまで3.のステップを繰り返す
1. あまりが0になったらその時割った数を数値として返す

#### Step3の方法
148 % 28 = 16　← 大きい数（148）を小さい数（28）で割る  
a % b = x

28 % 16 = 12　 ← 割った数（28）を余り（16）で割る  
b % x = y  

ということは？

a %= bでいいのでは？

#### Step1は必要ない
なぜならば  
小さい数から大きい数を割った時のあまりは割られる数になるためである。

```java
System.out.println(976 / 427); //2
System.out.println(976 % 427); //122

System.out.println(427 / 976); //0
System.out.println(427 % 976); //427
```

### 正解

```java
package practice;

public class Chapter15_1 {
    public static void main(String[] args) {
        int a = 976;
        int b = 427;
        System.out.println(a + " と " + b + " の最大公約数は、" + gcd(a, b) + "です。");
    }

    // ユークリッドの互除法で最大公約数を計算するメソッド
    static int gcd(int a, int b) {
        // b(余り)が0になった時のaが最大公約数
        if (b == 0) {
            return a;
        }
        // 再帰呼び出し
        return gcd(b, a % b);
    }
}
```


## 2 ファイルの入出力の問題
### 問題
JavaWcpの直下に「resources」ディレクトリ作成して、ディレクトリに以下の「input.txt」ファイルを作成してください。
作成した「input.txt」ファイルの読み込んで「output.txt」ファイルを出力するプログラム「Chapter15_2.java」を完成させてください。

### 解答
- IOExceprion  
入出力処理の失敗、または割り込みの発生によって生成される例外の汎用クラス


- Filesクラス

> Java1.7より追加されたAPIであるFilesクラスで、Fileクラスよりも高度なファイル操作を行うことができる。
Filesクラスは、基本的にPathクラスを引数にする。

```java
Path path = Paths.get("テスト");
Files.createDirectory(path);
```
このクラスファイルが存在するディレクトリに「テスト」という名前でディレクトリを新規作成する。

```java
Path path = Paths.get("テスト");
Files.createFile(path);
```
このクラスファイルが存在するディレクトリに「テスト」という名前でファイルを新規作成する。

- FileSystems.getDefaultメソッド
現在のファイルシステム取得

- Pathオブジェクトとは？  
Files クラスで用意されているメソッド使ってファイルやディレクトリに関する操作を行う場合に、ファイルやディレクトリを表すのに Path オブジェクトを作成して使用する。

- getPathメソッド  
Pathオブジェクトの生成ができる。

```java
Fileオブジェクト.getPath();
```

- BufferedReader

> テキストファイルを読み込むためのクラス。

- readlineメソッド

> テキストファイルを1行ずつ読み込むメソッド

BufferedReader bufferedReader = new BufferedReader(Fileオブジェクト);


### 正解

解説
「try-with-resources」文の基本構文は以下になります。

```java
try (初期化処理;) { 
    tryブロック（例外が発生する可能性がある処理）
} catch (例外クラス 変数名) {
    catchブロック（例外が発生した時に実行する処理）
} finally { 
    finallyブロック(例外発生の有無にかかわらず必ず実行する処理)
}
```

「try-catch-finally」文とほとんど同じですが、try文の後に「(初期化処理)」を記述する必要があります。
初期化処理では、クローズ処理を行う必要があるリソース関連クラスのインスタンスを生成します。「;」区切りで複数のリソースの初期ができます。
Javaでは、リソースをオープンした場合（インスタンスを生成した場合）は、必ず、クローズ処理をする必要があります。Java6以前は、finallyブロックにクローズ処理を記述する必要がありましたが、記述漏れなどによって、大きな問題が発生することがよくありました。
しかし、Java7以降に追加された「try-with-resources」はクローズ処理の記述が不要のため、記述漏れの心配がなく、また、ソースコードもすっきりするようになりました。














